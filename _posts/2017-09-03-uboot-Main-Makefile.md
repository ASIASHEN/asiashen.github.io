---
layout:     post
title:      uboot主Makefile分析
subtitle:   Samsung smdkv210板子uboot移植到九鼎 x210板子
date:       2017-09-03
author:     Mlin
header-img: img/post-bg-uboot-makefile.jpg
catalog: true
tags:
    - Makefile
    - 脚本语言
    - uboot
---


> 本文发布于 [Mlin Blog](http://happymiki.top)、[简书](http://www.jianshu.com/u/3f05018752b8)、[CSDN]()，作者 [@木林(Mlin)](http://github.com/happymiki) ,转载请保留原文链接。

> 上一篇文章 [《开启Makefile大门》](https://happymiki.github.io/2017/08/26/开启Makefile大门/)。


# 前言
u-boot是一种普遍用于嵌入式系统中的Bootloader,Bootloader是在操作系统运行之前执行的一小段程序，通过它，我们可以初始化硬件设备、建立内存空间的映射表，从而建立适当的软硬件环境，为最终调用操作系统内核做好准备。Boot Loader的主要运行任务就是将内核映象从硬盘上读到RAM中，然后跳转到内核的入口点去运行，即开始启动操作系统。系统在上电或复位时通常都从地址0x00000000处开始执行，而在这个地址处安排的通常就是系统的Boot Loader程序。

# 目录
- uboot version确定
- HOSTARCH和HOSTOS
- 静默编译
- 2种编译方法
- 编译方法实践
- 相关Makefile分析
- OBJTREE、SRCTREE、TOPDIR
- MKCONFIG
- include $(obj)include/config.mk
- ARCH CROSS_COMPILE
- $(TOPDIR)/config.mk
- 编译工具定义
- 包含开发板配置项目
- 链接脚本
- TEXT_BASE
- 自动推导规则
- 目标

# 正文
## 一、uboot version确定
(1) uboot的版本号分3个级别，在Makefile的24-29行：
	
	VERSION = 1
	PATCHLEVEL = 3
	SUBLEVEL = 4
	EXTRAVERSION =
	U_BOOT_VERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
	VERSION_FILE = $(obj)include/version_autogenerated.h

- **VERSION：主板本号**

- **PATCHLEVEL：次版本号(补丁版本号)**

- **SUBLEVEL：再次版本号**

- **EXTRAVERSION:另外附加的版本信息**

这3个用.分隔开共同构成了最终的版本号（1.3.4xxx）。

(2) Makefile中版本号最终生成了一个变量U_BOOT_VERSION，这个变量记录了Makefile中配置的版本号。

(3) include/version_autogenerated.h文件是编译过程中自动生成的一个文件，所以源目录中没有，但是编译过后的uboot中就有了。它里面的内容是一个宏定义，宏定义的值内容就是我们在Makefile中配置的uboot的版本号。

	#define U_BOOT_VERSION "U-Boot 1.3.4"
	
(4) 验证方法：自己修改主Makefile中几个Version有关的变量，然后重新编译uboot，然后烧录到SD卡中，从SD卡启动，然后去看启动时uboot打印出来的版本信息，看看变化是不是和自己的分析一致。

## 二、HOSTARCH和HOSTOS
(1) 直接在shell中执行uname -m得到i686，得到的值其实你当前执行这个命令的电脑的CPU的版本号。

	HOSTARCH := $(shell uname -m | \
		sed -e s/i.86/i386/ \
		    -e s/sun4u/sparc64/ \
		    -e s/arm.*/arm/ \
		    -e s/sa110/arm/ \
		    -e s/powerpc/ppc/ \
		    -e s/ppc64/ppc/ \
		    -e s/macppc/ppc/)

(2) shell中的" | "叫做管道，管道的作用就是把管道前面一个运算式的输出作为后面一个的输入再去做处理，最终的输出才是我们整个式子的输出。

(3) HOSTARCH这个名字：HOST是主机，就是当前在做开发用的这台电脑就叫主机；ARCH是architecture(架构)的缩写，表示CPU的架构。**所以HOSTARCH就表示主机的CPU的架构**。

(4) HOSTOS:主机的操作系统，shell执行uname -s得到Linux，然后执行后面变成linu，L变成小写。

	HOSTOS := $(shell uname -s | tr '[:upper:]' '[:lower:]' | \
		    sed -e 's/\(cygwin\).*/cygwin/')

(5) 这两个环境变量是主机的操作系统和主机的CPU架构，得出后保存备用，后面自然会用到。

(6) 然后由export导出全局变量。

	export	HOSTARCH HOSTOS

## 三、、静默编译
在Makefile的第50-54行：

	# Allow for silent builds
	ifeq (,$(findstring s,$(MAKEFLAGS)))
	XECHO = echo
	else
	XECHO = :
	endif

ifeq$( findstring string,text)表示从text中寻找string字样，如果找到了则返回text,如果没找到就返回空,显然MAKEFLAGS为空，所以 $(findstring s,$(MAKEFLAGS)) 返回为空，if语句为真，XECHO = echo，执行非静默编译，否则，执行静默编译(静默编译的意思就是在编译时控制台不打印任何信息)

findstring是一个查找字符串函数：

用法：

	$(findstring FIND,IN) 

函数名称：查找字符串函数—findstring。 

函数功能：搜索字串“IN”，查找“FIND”字串。 

返回值：如果在“IN”之中存在“FIND” ，则返回“FIND”，否则返回空。 

函数说明：字串“IN”之中可以包含空格、[Tab]。搜索需要是严格的文本匹配。 

示例： 

	$(findstring a,a b c) 
	$(findstring a,b c) 

第一个函数结果是字“a”；第二个值为空字符。


(1) 平时默认编译时命令行会打印出来很多编译信息。但是有时候我们不希望看到这些编译信息，就后台编译即可。这就叫静默编译。

(2) 使用方法就是编译时make -s，-s会作为MAKEFLAGS传给Makefile，在50-54行这段代码作用下XECHO变量就会被变成空（默认等于echo），于是实现了静默编译。

## 四、2种编译方法
两种编译方法分别是：**原地编译和单独输出文件夹编译**

(1) 编译复杂项目，Makefile提供2种编译管理方法。默认情况下是当前文件夹中的.c文件，编译出来的.o文件会放在同一文件夹下。这种方式叫原地编译。原地编译的好处就是处理起来简单。

(2) 原地编译有一些坏处：第一，污染了源文件目录。第二的缺陷就是一套源代码只能按照一种配置和编译方法进行处理，无法同时维护2个或2个以上的配置编译方式。

(3) 为了解决以上2种缺陷，uboot支持单独输出文件夹方式的编译（linux kernel也支持，而且uboot的这种技术就是从linux kernel学习来的）。基本思路就是在编译时另外指定一个输出目录，将来所有的编译生成的.o文件或生成的其他文件全部丢到那个输出目录下去。源代码目录不做任何污染，这样输出目录就承载了本次配置编译的所有结果。

(4)具体用法：默认的就是原地编译。如果需要指定具体的输出目录编译则有2种方式来指定输出目录。（具体参考Makefile 56-76行注释内容）

- 第一种：make O=输出目录       
- 第二种：export BUILD_DIR=输出目录 然后再make,如果两个都指定了（既有BUILD_DIR环境变量存在，又有O=xx），则O=xx具有更高优先级，听他的。

(5) 两种编译的实现代码在Makefile的78-123行。

## 五、编译方法实践

在shell执行：
......

## 六、相关Makefile分析


## 七、OBJTREE、SRCTREE、TOPDIR
(1)OBJTREE：**编译出的.o文件存放的目录的根目录**。在默认编译下，OBJTREE等于当前目录；在O=xx编译下，OBJTREE就等于我们设置的那个输出目录。

(2)SRCTREE: 源码目录，其实就是源代码的根目录，也就是当前目录。

	OBJTREE		:= $(if $(BUILD_DIR),$(BUILD_DIR),$(CURDIR))
	SRCTREE		:= $(CURDIR)
	TOPDIR		:= $(SRCTREE)
	LNDIR		:= $(OBJTREE)
	export	TOPDIR SRCTREE OBJTREE

总结：在默认编译下，OBJTREE和SRCTREE相等；在O=xx这种编译下OBJTREE和SRCTREE不相等。Makefile中定义这两个变量，其实就是为了记录编译后的.o文件往哪里放，就是为了实现O=xx的这种编译方式的。

## 八、MKCONFIG
在Makefile的第101行：

	MKCONFIG	:= $(SRCTREE)/mkconfig
	export MKCONFIG

(1)Makefile中定义的一个变量（在这里定义，在后面使用），它的值就是我们源码根目录下面的mkconfig。这个mkconfig是一个脚本，这个脚本就是uboot配置阶段的配置脚本。

## 九、include $(obj)include/config.mk
在Makefile的第133行：

	# load ARCH, BOARD, and CPU configuration
	include $(obj)include/config.mk
	export	ARCH CPU BOARD VENDOR SOC

(1)include/config.mk不是源码自带的（你在没有编译过的源码目录下是找不到这个文件的），要在配置过程（make x210_sd_config）中才会生成这个文件。因此这个文件的值和我们配置过程有关，是由配置过程根据我们的配置自动生成的。

(2)我们X210在iNand情况下配置生成的config.mk内容为：

- ARCH   = arm
- CPU    = s5pc11x
- BOARD  = x210
- VENDOR = samsung
- SOC    = s5pc110

(3)我们在下一行（134行）export导出了这5个变量作为环境变量。所以着两行加起来其实就是为当前makefile定义了5个环境变量而已。之所以不直接给出这5个环境变量的值，是因为我们希望这5个值是可以被人很容易的、集中的配置的。

(4)这里的配置值来自于2589行那里的配置项。如果我们要更改这里的某个配置值要到2589行那里调用MKCONFIG脚本传参时的参数。

	x210_sd_config :	unconfig
		@$(MKCONFIG) $(@:_config=) arm s5pc11x x210 samsung s5pc110
		@echo "TEXT_BASE = 0xc3e00000" > $(obj)board/samsung/x210/config.mk

## 十、ARCH CROSS_COMPILE
(1)接下来有2个很重要的环境变量。一个是ARCH，上面导出的，值来自于我们的配置过程，它的值会影响后面的CROSS_COMPILE环境变量的值。ARCH的意义是定义当前编译的目标CPU的架构。

	ifeq ($(ARCH),arm)
	#CROSS_COMPILE = arm-linux-
	#CROSS_COMPILE = /usr/local/arm/4.4.1-eabi-cortex-a8/usr/bin/arm-linux-
	#CROSS_COMPILE = /usr/local/arm/4.2.2-eabi/usr/bin/arm-linux-
	CROSS_COMPILE = /usr/local/arm/arm-2009q3/bin/arm-none-linux-gnueabi-
	endif

(2)CROSS_COMPILE是定义交叉编译工具链的前缀的。定义这些前缀是为了在后面用（用前缀加上后缀来定义编译过程中用到的各种工具链中的工具）。我们把前缀和后缀分开还有一个原因就是：在不同CPU架构上的交叉编译工具链，只是前缀不一样，后缀都是一样的。因此定义时把前缀和后缀分开，只需要在定义前缀时区分各种架构即可实现可移植性。

(3)CROSS_COMPILE在136-182行来确定。CROSS_COMPILE是被ARCH所确定的，只要配置了ARCH=arm，那么我们就只能在ARM的那个分支去设置CROSS_COMPILE的值。这个设置值只要能保证找到那个交叉编译工具链即可，不一定非得是全路径的，相对路径也可以。（如果已经将工具链导出到环境变量，并且设置了符号链接，这样CROSS_COMPILE = arm-linux-就可以）

	# load ARCH, BOARD, and CPU configuration
	include $(obj)include/config.mk
	export	ARCH CPU BOARD VENDOR SOC
	
	ifndef CROSS_COMPILE
	ifeq ($(HOSTARCH),$(ARCH))
	CROSS_COMPILE =
	else
	ifeq ($(ARCH),ppc)
	CROSS_COMPILE = ppc_8xx-
	endif
	ifeq ($(ARCH),arm)
	#CROSS_COMPILE = arm-linux-
	#CROSS_COMPILE = /usr/local/arm/4.4.1-eabi-cortex-a8/usr/bin/arm-linux-
	#CROSS_COMPILE = /usr/local/arm/4.2.2-eabi/usr/bin/arm-linux-
	CROSS_COMPILE = /usr/local/arm/arm-2009q3/bin/arm-none-linux-gnueabi-
	endif
	ifeq ($(ARCH),i386)
	CROSS_COMPILE = i386-linux-
	endif
	ifeq ($(ARCH),mips)
	CROSS_COMPILE = mips_4KC-
	endif
	ifeq ($(ARCH),nios)
	CROSS_COMPILE = nios-elf-
	endif
	ifeq ($(ARCH),nios2)
	CROSS_COMPILE = nios2-elf-
	endif
	ifeq ($(ARCH),m68k)
	CROSS_COMPILE = m68k-elf-
	endif
	ifeq ($(ARCH),microblaze)
	CROSS_COMPILE = mb-
	endif
	ifeq ($(ARCH),blackfin)
	CROSS_COMPILE = bfin-uclinux-
	endif
	ifeq ($(ARCH),avr32)
	CROSS_COMPILE = avr32-linux-
	endif
	ifeq ($(ARCH),sh)
	CROSS_COMPILE = sh4-linux-
	endif
	ifeq ($(ARCH),sparc)
	CROSS_COMPILE = sparc-elf-
	endif	# sparc
	endif	# HOSTARCH,ARCH
	endif	# CROSS_COMPILE
	
	export	CROSS_COMPILE

(4)实际运用时，我们可以在Makefile中去更改设置CROSS_COMPILE的值，也可以在编译时用make CROSS_COMPILE=xxxx来设置，而且编译时传参的方法可以覆盖Makefile里面的设置。

## 十一、$(TOPDIR)/config.mk
在Makefile的第185行：

	# load other configuration
	include $(TOPDIR)/config.mk

## 编译工具定义
在config.mk 94-107行

	#
	# Include the make variables (CC, etc...)
	#
	AS	= $(CROSS_COMPILE)as
	LD	= $(CROSS_COMPILE)ld
	CC	= $(CROSS_COMPILE)gcc
	CPP	= $(CC) -E
	AR	= $(CROSS_COMPILE)ar
	NM	= $(CROSS_COMPILE)nm
	LDR	= $(CROSS_COMPILE)ldr
	STRIP	= $(CROSS_COMPILE)strip
	OBJCOPY = $(CROSS_COMPILE)objcopy
	OBJDUMP = $(CROSS_COMPILE)objdump
	RANLIB	= $(CROSS_COMPILE)RANLIB


## 十二、包含开发板配置项目
在config.mk, 112行

	# Load generated board configuration
	sinclude $(OBJTREE)/include/autoconf.mk

(1)autoconfig.mk文件不是源码提供的，是配置过程自动生成的。

(2)这个文件的作用就是用来指导整个uboot的编译过程。这个文件的内容其实就是很多CONFIG_开头的宏（可以理解为变量），这些宏/变量会影响我们uboot编译过程的走向（原理就是条件编译）。在uboot代码中有很多地方使用条件编译进行编写，这个条件编译是用来实现可移植性的。（可以说uboot的源代码在很大程度来说是拼凑起来的，同一个代码包含了各种不同开发板的适用代码，用条件编译进行区别。）

(3)这个文件不是凭空产生的，配置过程也是需要原材料来产生这个文件的。原材料在源码目录的inlcude/configs/xxx.h头文件。（X210开发板中为include/configs/x210_sd.h）。这个h头文件里面全都是宏定义，这些宏定义就是我们对当前开发板的移植。每一个开发板的移植都对应这个目录下的一个头文件，这个头文件里每一个宏定义都很重要，这些配置的宏定义就是我们移植uboot的关键所在。

## 十三、链接脚本
在config.mk 142-149行

	ifndef LDSCRIPT
	#LDSCRIPT := $(TOPDIR)/board/$(BOARDDIR)/u-boot.lds.debug
	ifeq ($(CONFIG_NAND_U_BOOT),y)
	LDSCRIPT := $(TOPDIR)/board/$(BOARDDIR)/u-boot-nand.lds
	else
	LDSCRIPT := $(TOPDIR)/board/$(BOARDDIR)/u-boot.lds
	endif
	endif

(1)如果定义了CONFIG_NAND_U_BOOT宏，则链接脚本叫u-boot-nand.lds，如果未定义这个宏则链接脚本叫u-boot.lds（uboot/uboot_jiuding/board/samsung/x210/u-boot.lds）。

(2)从字面意思分析，即可知：CONFIG_NAND_U_BOOT是在Nand版本情况下才使用的，我们使用的X210都是iNand版本的，因此这个宏没有的。

(3)实际在board\samsung\x210目录下有u-boot.lds，这个就是链接脚本。我们在分析uboot的编译链接过程时就要考虑这个链接脚本。

## 十四、TEXT_BASE
在config.mk 156-158行：

	ifneq ($(TEXT_BASE),)
	CPPFLAGS += -DTEXT_BASE=$(TEXT_BASE)
	endif

(1)Makefile中在配置X210开发板时，在board/samsung/x210目录下生成了一个文件config.mk，其中的内容就是：TEXT_BASE = 0xc3e00000相当于定义了一个变量。

(2)TEXT_BASE是将来我们整个uboot链接时指定的链接地址。因为uboot中启用了虚拟地址映射，因此这个C3E00000地址就等于0x23E00000(也可能是33E00000具体地址要取决于uboot中做的虚拟地址映射关系)。

(3)回顾裸机中讲的链接地址的问题，再想想dnw方式先下载x210_usb.bin然后再下载uboot.bin时为什么第二个地址是23E00000.

## 十五、自动推导规则
在config.mk 239-256行：

	ifndef REMOTE_BUILD
	
	%.s:	%.S
		$(CPP) $(AFLAGS) -o $@ $<
	%.o:	%.S
		$(CC) $(AFLAGS) -c -o $@ $<
	%.o:	%.c
		$(CC) $(CFLAGS) -c -o $@ $<
	
	else
	
	$(obj)%.s:	%.S
		$(CPP) $(AFLAGS) -o $@ $<
	$(obj)%.o:	%.S
		$(CC) $(AFLAGS) -c -o $@ $<
	$(obj)%.o:	%.c
		$(CC) $(CFLAGS) -c -o $@ $<
	endif

(1)我们在讲Makefile时提到过自动推导规则，具体理解可以参考《跟我一起学Makefile》

## 十六、目标

(1)291行出现了整个主Makefile中第一个目标all（也就是默认目标，我们直接在uboot根目录下make其实就等于make all，就等于make这个目标）

	all:		$(ALL)

(2)目标中有一些比较重要的。譬如：u-boot是最终编译链接生成的elf格式的可执行文件。

(3)unconfig字面意思来理解就是未配置。这个符号用来做为我们各个开发板配置目标的依赖。目标是当我们已经配置过一个开发板后再次去配置时还可以配置。

(4)我们配置开发板时使用：make x210_sd_config，因此分析x210_sd_config肯定是主Makefile中的一个目标。

# 结语
